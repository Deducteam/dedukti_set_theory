require open zf.theoriezf.logic;
require open zf.theoriezf.language;
require open zf.theoriezf.lemmas1_6;
require open zf.theoriezf.lemmas7_13;

opaque symbol lemma14 : π(∀ g (λ a, ∀ n (λ x, ∀ n (λ y', (eta (join a) x (i y')) ⇔ (∃ n (λ y, (x = i y) ∧ (eta a y y')))))))
≔ begin
assume a x y';
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H1;
apply ExElim n _ H1 _;
assume y Hy;
apply ExElim n _ Hy _;
assume y'' Hy'';
apply ExIntro n y _ _;
apply and_i;
apply and_eg _ _ (and_eg _ _ Hy'');
apply imp_i (y' = y'') _ _ _;
assume H2;
apply imp_i (y'' = y') _ _ _;
assume H3;
apply H3 (λ z, eta a y z) (and_ed _ _ Hy'');
apply lemmaSymEg _ _ H2;
apply lemma9 _ _ (and_ed _ _ (and_eg _ _ Hy''));
assume H4;
apply f_e _ _;
apply ExElim n _ H4 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply lemma11 y' _;
apply and_ed _ _ (and_eg _ _ (and_eg _ _ Hz));
assume H;
apply ExElim n _ H _;
assume y Hy;
apply or_ig;
apply ExIntro n y _ _;
apply ExIntro n y' _ _;
apply and_i _ _ (and_i _ _ (and_eg _ _ Hy) (lemma1 (i y'))) (and_ed _ _ Hy);
end;

opaque symbol lemma15 : π(∀ g (λ a, ∀ n (λ x, (eta (join a) x o) ⇔ (∃ n (λ y, ∃ n (λ z, (x = i y) ∧ (eta a y z) ∧ (eta a z (root a))))))))
≔ begin
assume a x;
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H1;
apply f_e _ _;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume y' Hy';
apply lemma11 y' _;
apply lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hy'));
assume H2;
apply ExElim n _ H2 _;
assume y Hy;
apply ExElim n _ Hy _;
assume z Hz;
apply ExIntro n y _ _;
apply ExIntro n z _ _;
apply and_i;
apply and_i;
apply and_eg _ _ (and_eg _ _ (and_eg _ _ Hz));
apply (and_ed _ _ (and_eg _ _ Hz));
apply and_ed _ _ Hz;
assume H;
apply or_id;
apply ExElim n _ H _;
assume y Hy;
apply ExElim n _ Hy _;
assume z Hz;
apply ExIntro n y _ _;
apply ExIntro n z _ _;
apply and_i;
apply and_i;
apply and_i _ _ (and_eg _ _ (and_eg _ _ Hz)) (lemma1 o);
apply and_ed _ _ (and_eg _ _ Hz);
apply and_ed _ _ Hz;
end;

opaque symbol lemma16 : π(∀ g (λ a, ∀ g (λ b, ∀ n (λ x, ∀ n (λ y', (eta (pair a b) x (i y')) ⇔ (∃ n (λ y, (x = i y) ∧ (eta a y y'))))))))
≔ begin
assume a b x y';
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H'';
apply or_e _ _ _ H'' _ _;
assume H1;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply ExIntro n y _ _;
apply and_i;
apply and_eg _ _ (and_eg _ _ Hz);
apply imp_i (y' = z) _ _ _;
assume H2;
apply imp_i (z = y') _ _ _;
assume H3;
apply H3 (λ w, eta a y w) (and_ed _ _ Hz);
apply lemmaSymEg _ _ H2;
apply lemma9 _ _ (and_ed _ _ (and_eg _ _ Hz));
assume H5;
apply f_e _ _;
apply ExElim n _ H5 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply lemma13 y' z (and_ed _ _ (and_eg _ _ Hz));
assume H6;
apply f_e _ _;
apply lemma11 y' (and_ed _ _ H6);
assume H7;
apply f_e _ _;
apply lemma11 y' (and_ed _ _ H7);
assume H;
apply or_ig;
apply or_ig;
apply or_ig;
apply ExElim n _ H _;
assume y Hy;
apply ExIntro n y _ _;
apply ExIntro n y' _ _;
apply and_i _ _ (and_i _ _ (and_eg _ _ Hy) (lemma1 (i y'))) (and_ed _ _ Hy);
end;

opaque symbol lemma17 : π(∀ g (λ a, ∀ g (λ b, ∀ n (λ x, ∀ n (λ y', (eta (pair a b) x (j y')) ⇔ (∃ n (λ y, (x = j y) ∧ (eta b y y'))))))))
≔ begin
assume a b x y';
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H'';
apply or_e _ _ _ H'' _ _;
assume H1;
apply f_e _ _;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply lemma13 z y' (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hz)));
assume H2;
apply ExElim n _ H2 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply ExIntro n y _ _;
apply and_i;
apply and_eg _ _ (and_eg _ _ Hz);
apply imp_i (y' = z) _ _ _;
assume H3;
apply imp_i (z = y') _ _ _;
assume H4;
apply H4 (λ w, eta b y w) (and_ed _ _ Hz);
apply lemmaSymEg _ _ H3;
apply lemma10 _ _ (and_ed _ _ (and_eg _ _ Hz));
assume H5;
apply f_e _ _;
apply lemma12 y' (and_ed _ _ H5);
assume H6;
apply f_e _ _;
apply lemma12 y' (and_ed _ _ H6);
assume H;
apply or_ig;
apply or_ig;
apply or_id;
apply ExElim n _ H _;
assume y Hy;
apply ExIntro n y _ _;
apply ExIntro n y' _ _;
apply and_i _ _ (and_i _ _ (and_eg _ _ Hy) (lemma1 (j y'))) (and_ed _ _ Hy);
end;

opaque symbol lemma18 : π(∀ g (λ a, ∀ g (λ b, ∀ n (λ x, (eta (pair a b) x o) ⇔ ((x = i (root a)) ∨ (x = j (root b)))))))
≔ begin
assume a b x;
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H'';
apply or_e _ _ _ H'' _ _;
assume H1;
apply f_e _ _;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply lemma11 z (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hz)));
assume H2;
apply f_e _ _;
apply ExElim n _ H2 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply lemma12 z (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hz)));
assume H3;
apply or_ig _ _ (and_eg _ _ H3);
assume H4;
apply or_id _ _ (and_eg _ _ H4);
assume H;
apply or_e _ _ _ H _ _;
assume Hi;
apply or_ig;
apply or_id;
apply and_i _ _ Hi (lemma1 o);
assume Hj;
apply or_id;
apply and_i _ _ Hj (lemma1 o);
end;
