require open zf.theoriezf.logic;
require open zf.theoriezf.language;
require open zf.theoriezf.lemmas1_6;
require open zf.theoriezf.lemmas7_13;
require open zf.theoriezf.lemmas14_18;

opaque symbol lemma19 : π(∀ g (λ a, ∀ n (λ x, ∀ n (λ y', (eta (powerset a) x (i y')) ⇔ (∃ n (λ y, (x = i y) ∧ (eta a y y')))))))
≔ begin
assume a x y';
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H1;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume z Hz;
apply ExIntro n y _ _;
apply and_i;
apply and_eg _ _ (and_eg _ _ Hz);
apply imp_i (y' = z) _ _ _;
assume H2;
apply imp_i (z = y') _ _ _;
assume H3;
apply H3 (λ w, eta a y w) (and_ed _ _ Hz);
apply lemmaSymEg _ _ H2;
apply lemma9 _ _ (and_ed _ _ (and_eg _ _ Hz));
assume H4;
apply f_e _ _;
apply ExElim n _ H4 _; 
assume y Hy;
apply ExElim g _ Hy _; 
assume c Hc;
apply lemma13 y' (ρ c) (and_ed _ _ (and_eg _ _ (and_eg _ _ Hc)));
assume H5;
apply f_e _ _;
apply ExElim g _ H5 _; 
assume c Hc;
apply lemma11 y' (and_ed _ _ Hc);
assume H;
apply ExElim n _ H _;
assume y Hy;
apply or_ig;
apply or_ig;
apply ExIntro n y _ _;
apply ExIntro n y' _ _;
apply and_i _ _ (and_i _ _ (and_eg _ _ Hy) (lemma1 (i y'))) (and_ed _ _ Hy);
end;

opaque symbol lemma20 : π(∀ g (λ a, ∀ g (λ c, ∀ n (λ x, (eta (powerset a) x (j (ρ c))) ⇔ (∃ n (λ y, (x = i y) ∧ (eta a y (root a)) ∧ ((cr a y) ∈ c )))))))
≔ begin
assume a c x;
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H1;
apply f_e _ _;
apply ExElim n _ H1 _; 
assume y Hy;
apply ExElim n _ Hy _; 
assume y' Hy';
apply lemma13 y' (ρ c) (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hy')));
assume H2;
apply ExElim n _ H2 _; 
assume y Hy;
apply ExElim g _ Hy _; 
assume c' Hc';
apply ExIntro n y _ _;
apply and_i;
apply and_i;
apply and_eg _ _ (and_eg _ _ (and_eg _ _ Hc'));
apply and_ed _ _ (and_eg _ _ Hc');
apply ExElim n _ (and_ed _ _ Hc');
assume z Hz;
apply ExIntro n z _ _;
apply and_i;
apply imp_e (ρ c = ρ c') _ _ _;
assume H3;
apply imp_e (ρ c' = ρ c) _ _ _;
assume H4;
apply imp_e (eta (ρ^ (ρ c)) z (root (ρ^ (ρ c)))) (eta c z (root c));
assume P;
apply P;
apply H4 (λ w, eta (ρ^ w) z (root (ρ^ w)));
apply and_eg _ _ Hz;
apply lemmaSymEg _ _ H3;
apply lemma10 _ _ (and_ed _ _ (and_eg _ _ (and_eg _ _ Hc')));
apply ExElim relat _ (and_ed _ _ Hz) _; 
assume r Hr;
apply ExIntro relat r _ _;
apply and_i;
apply and_i;
apply and_eg _ _ (and_eg _ _ Hr);
assume u u' v Heta;
apply imp_e (ρ c = ρ c') _ _ _;
assume H5;
apply imp_e (ρ c' = ρ c) _ _ _;
assume H6;
apply ExElim n _ ((and_ed _ _ (and_eg _ _ Hr)) u u' v Heta) _;
assume y' Hy';
apply ExIntro n y' _ _;
apply imp_e (eta (ρ^ (ρ c)) y' v ∧ r u' y') (eta c y' v ∧ r u' y');
assume P;
apply P;
apply H6 (λ w, eta (ρ^ w) y' v ∧ r u' y');
apply Hy';
apply lemmaSymEg _ _ H5;
apply lemma10 _ _ (and_ed _ _ (and_eg _ _ (and_eg _ _ Hc')));
assume v v' u Heta;
apply (and_ed _ _ Hr) v v' u _;
apply imp_e (ρ c' = ρ c) _ _ _;
assume H7;
apply imp_e (ρ c = ρ c') _ _ _;
assume H8;
apply imp_e (eta (ρ^ (ρ c')) v' v ∧ r u v) (eta c' v' v ∧ r u v);
assume P;
apply P;
apply H8 (λ w, eta (ρ^ w) v' v ∧ r u v);
apply Heta;
apply lemmaSymEg _ _ H7;
apply lemma10 _ _ (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ (and_eg _ _ Hc'))));
assume H9;
apply f_e _ _;
apply ExElim g _ H9 _; 
assume c' Hc';
apply lemma12 (ρ c) (and_ed _ _ Hc');
assume H;
apply or_ig;
apply or_id;
apply ExElim n _ H _;
assume y Hy;
apply ExIntro n y _ _;
apply ExIntro g c _ _;
apply and_i;
apply and_i;
apply and_i _ _ (and_eg _ _ (and_eg _ _ Hy)) (lemma1 (j (ρ c)));
apply and_ed _ _ (and_eg _ _ Hy);
apply and_ed _ _ Hy;
end;

opaque symbol lemma21 : π(∀ g (λ a, ∀ n (λ x, (eta (powerset a) x o) ⇔ (∃ g (λ c, (x = j (ρ c)))))))
≔ begin
assume a x;
apply and_i;
assume H;
apply or_e _ _ _ H _ _;
assume H';
apply or_e _ _ _ H' _ _;
assume H1;
apply f_e _ _;
apply ExElim n _ H1;
assume y Hy;
apply ExElim n _ Hy; 
assume y' Hy';
apply lemma11 y' (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ Hy')));
assume H2;
apply f_e _ _;
apply ExElim n _ H2;
assume y Hy;
apply ExElim g _ Hy; 
assume c Hc;
apply lemma12 (ρ c) (lemmaSymEg _ _ (and_ed _ _ (and_eg _ _ (and_eg _ _ Hc))));
assume H3;
apply ExElim g _ H3;
assume c Hc;
apply ExIntro g c _ _;
apply and_eg _ _ Hc;
assume H;
apply ExElim g _ H _;
assume c Hc;
apply or_id;
apply ExIntro g c _ _;
apply and_i _ _ Hc (lemma1 o);
end;

