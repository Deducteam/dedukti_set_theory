\documentclass[a4paper]{article}

\usepackage[top=3.5cm, bottom=3.5cm, left=3.5cm, right=3.5cm]{geometry}
\usepackage{ae,lmodern}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage[backend=biber,style=alphabetic]{biblatex}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{enumitem}
\setitemize[1]{label=---}

\title{\textbf{Dedukti: an implementation of set theory with pointed graphs} (titre provisoire)}
\date{}

\input{macros.tex}
\input{lambdapi.tex}
\addbibresource{ref.bib}

\begin{document}
\thispagestyle{empty}
\maketitle

\begin{abstract}
We show how to implement set theory in \dedukti ~in such a way that it respects normalization. To do so, we adapt in $\lambda \Pi$\textit{--calculus modulo theory} the guideline given in \textit{Deduction modulo} by G. Dowek and A. Miquel --using a theory of pointed graphs. To achieve this goal, we develop a language of formulas.
\end{abstract}

\section{Introduction}

\dedukti \ is a logical framework based upon the language \lpcm, which was created to overcome the lack of interoperability between proof assistants. As it is a logical framework, we can implement theories in \dedukti. Especially, set theory is interesting beacause it will enable traductions from and towards proof assistants using set theory, such as \textsc{Isabelle/ZF}.

A previous work by G. Dowek and A. Miquel \cite{zermodulo} has demonstrated the implemtation of set theory in \textit{Deduction modulo} thaks to a structure of \textit{pointed graphs}. Since the writing of \cite{zermodulo}, \lpcm \ has been created as an improvement of \textit{Deduction modulo}. We adapt the implementation to the \lpcm \ and then implement it in \dedukti. 

\section{The theory of pointed graphs}

To implement set theory in \dedukti, the first idea is to translate the axioms of the theory into rewriting rules. Nevertheless, as pointed out by M. Crabbé \cite{crabbé}, such implementation does not guarantee normalization. That is why G. Dowek and A. Miquel \cite{zermodulo} introduced a structure of pointed graphs to set theory. This set theory with pointed graphs -- called IZmod -- respects normalization.

\subsection{Pointed graphs}

In this theory, sets are reprented by pointed graphs. A pointed graph is a direct graph whom one of its node is identified as the root. 

\begin{figure}[h]
\begin{tikzpicture}[>=stealth,yscale=1.8,xscale=1.4]  

\node(a) at (3,3)[circle,draw,text centered] {a};
\node(b) at (5,3)[circle,draw,text centered] {b};
\node(c) at (5,2.5)[circle,draw,text centered] {c};
\node(d) at (7,3)[circle,draw,text centered] {d};
\node(e) at (6.5,2.5)[circle,draw,text centered] {e};
\node(f) at (7.5,2.5)[circle,draw,text centered] {f};
\node(g) at (7.5,2)[circle,draw,text centered] {g};
                      
\draw[->] (b) -- (c); 
\draw[->] (d) -- (e);
\draw[->] (d) -- (f);
\draw[->] (f) -- (g);

\end{tikzpicture}
\end{figure}

The first graph with root $a$ represents the set $\emptyset$. The second graph with root $b$ represents the set $\{\emptyset\}$, while with root c it represents $\emptyset$. The third graph with root $d$ represents $\{\emptyset,\{\emptyset\}\}$, \textit{etc}.

The operator $root$ gives the root of a pointed graph. $a/x$ replace the root of $a$ by $x$. $x~\eta_a~y$ means there is a edge in $a$ from $y$ to $x$. $rel(x,y,r)$ means that the nodes $x$ and $y$ are related by the relation $r$. We have the following rewriting rules:
$$ x \ \eta_{a/z} \ y \longrightarrow x \ \eta_a \ y $$
$$ \text{root}(a/x) \longrightarrow x $$
$$ (a/x)/y \longrightarrow a/y $$

We saw in the examples that some different pointed graphs can represent the same set. To characterized this, G. Dowek and A. Miquel introduce bisimilarity between graphs (noted $\simeq$): 

$a \simeq b \lra \ex r~(rel(root(a),root(b),r) \\
\conj \ \fa x \fa x'~\fa y~(x'~\eta_a~x~\conj~rel(x, y, r)~\imp~\ex~y'~(y'~\eta_b~y~\conj~rel(x', y', r))) \\
\conj \ \fa y \fa y'~\fa x~(y'~\eta_b~y~\conj~rel(x, y, r)~\imp~\ex~x'~(x'~\eta_a~x~\conj~rel(x', y', r))))$

\begin{figure}[h]
\begin{tikzpicture}[>=stealth,yscale=1.8,xscale=1.4]  

\node(b) at (5,3)[circle,draw,text centered,fill=gray] {b};
\node(c) at (5,2.5)[circle,draw,text centered] {c};
\node(d) at (7,3)[circle,draw,text centered] {d};
\node(e) at (6.5,2.5)[circle,draw,text centered] {e};
\node(f) at (7.5,2.5)[circle,draw,text centered,fill=gray] {f};
\node(g) at (7.5,2)[circle,draw,text centered] {g};
\node(h) at (5.75,2.75)[text centered]{$\simeq$};
\node(i) at (10,2.5)[text width=4cm,text centered] {The root is noted with the filled circle.};
                      
\draw[->] (b) -- (c); 
\draw[->] (d) -- (e);
\draw[->] (d) -- (f);
\draw[->] (f) -- (g);

\end{tikzpicture}
\end{figure}

The objective is to composed pointed graphs, for instance to join pointed graphs. The root of the new pointed graph is $o$. To guarantee that $o$ is not a node of one of the original pointed graphs, an injective function $i$ is introduced, such as its left inverse $i'$ and its image $I$. 
$$i'(i(x)) \lra x$$
$$ I(x) \lra \top $$
$$ I(o) \lra \bot $$

The same method is applied to constructors $pair$, $powerset$, $etc$.

\subsection{Set theories}

Many definitions of the set theory intervines. The two classical set theories are Zermelo (Z) and Zermelo-Fraenkel (ZF). The set theory defined in \textit{Deduction modulo} by G. Dowek and A. Miquel \cite{zermodulo} is stronger than Zermelo set theory but weaker than Zermelo-Fraenkel set thery. Indeed, IZst contains Zermelo set theory, the Strong Extensionality axiom and the Transitive Closure axiom. \\

\textbf{Strong Extensionality axiom.} $\fa~x_1,...,\fa~x_n,\fa~a,\fa~b, \\
(R(a, b) \\
\conj~\fa~x,\fa~x',\fa~y,(x' \in x \conj R(x, y) \imp \ex~y', (y' \in y \conj R(x', y'))) \\
\conj \fa~y,\fa~y',\fa~x, (y' \in y \conj R(x, y) \imp \ex~x'(x' \in x \conj R(x', y'))) \\
\imp a = b) $

where $R(a,b)$ is a formula of free variables $x_1, ..., x_n$. \\

\textbf{Transitive Closure axiom.} $\fa~a,\ex~e, (a \subseteq e \conj \fa~x,\fa~y, (x \in y \conj y \in e \imp x \in e))$ \\

The Strong Extensionality axiom can be deduced from the Foundation axiom and the Transitive Closure axiom is can be derived from Replacement Scheme.

The Strong Extensionality axiom implies the Extensionality axiom\footnote{See \ref{extensionality}}.

\begin{figure}[h]
\begin{tikzpicture}[>=stealth,yscale=1,xscale=1]  

\draw[rounded corners=3pt] (0.5,0.5) rectangle (4,5);
\draw[rounded corners=3pt] (0.25,0.25) rectangle (8,5.25);
\draw[rounded corners=3pt] (0,0) rectangle (12,5.5);

\node(a) at (2.25,3)[text width=3cm,text centered] {\textbf{Z} \\ Pairing \\ Union \\ Extensionality \\ Powerset \\ Comprehension \\ Infinity};
\node(b) at (6,3)[text width=10cm,text centered] {\textbf{IZst} \\ Transitive Closure \\ Strong Extensionality};
\node(c) at (10,3)[text width=3cm,text centered] {\textbf{ZF} \\ Replacement \\ Foundation};

\end{tikzpicture}
\caption{View of the different set theories}
\end{figure}


\section{The language of pointed graphs}

\subsection{Sorts}

The langage of the theory IZmod uses four sorts. The first two are for
the pointed graphs and for the nodes of the pointed graphs.  In
\dedukti, we would need two universal quantifiers and two
existential quantifiers, one for each sort.  We rather use another
solution \cite{theoryU} that is to declare a constant $\Set$ of type
$\Type$ for codes of sorts, a function $\El$ of type $\Set \ra \Type$,
two constants $graph$ and $node$ of sort $\Set$.

\begin{lstlisting}
constant symbol graph : Set;
constant symbol node : Set;
\end{lstlisting}

The two other sorts of the theory IZmod are for classes of nodes and
for binary relations on nodes.  In \dedukti, the sort of classes is
just $\El~node \ra \El~prop$ and that of binary relations
$\El~node \ra \El~node \ra \El~prop$. To quantify on such sorts, we introduce constant $\arr $ of type
$\Set \ra \Set \ra \Set$ and rewrite rule
$$\El~(x~\arr~y) \lra (\El~x) \ra (\El~y)$$

The symbols $graph$ and $node$ are specific to the
expression of $IZmod$ in \dedukti. In contrast the symbols $\Set$,
$\El$, $prop$, and $\arr$ are part of the standard library of 
\dedukti.

\subsection{Signature}

The signature of $IZmod$ contains 31 symbols. As we have replaced the
sorts for classes and relations with the \dedukti \ types
$\El~node \ra \El~prop$ and $\El~node \ra \El~node \ra \El~prop$, we do not need specific predicate symbols to apply a class to a node or a relations to two. In the same way, we do not need comprehension axioms for classes and relations. 

Similarly, the equality symbol is part of the standard library of \dedukti.

The signature is thus reduced to 26 symbols. The specific case of the comprehension symbol is treated later.

\begin{lstlisting}
symbol eta : El graph → El node → El node → El prop;
symbol root : El graph → El node;
symbol cr : El graph → El node → El graph;
constant symbol o : El node;
constant symbol O : El node;
symbol i : El node → El node;
symbol i' : El node → El node;
symbol j : El node → El node;
symbol j' : El node → El node;
symbol I : El node → El prop;
symbol J : El node → El prop;
symbol ρ : El graph → El node;
symbol ρ^ : El node → El graph;
symbol Succ : El node → El node;
symbol Pred : El node → El node;
symbol Null : El node → El prop;
symbol Nat : El node → El prop;
symbol < : El node → El node → El prop;
symbol simeq : El graph → El graph → El prop;
symbol ∈ : El graph → El graph → El prop;
symbol join : El graph → El graph;
symbol pair : El graph → El graph → El graph;
symbol powerset : El graph → El graph;
symbol omega : El graph;
symbol Cl : El graph → El graph;
\end{lstlisting}

\subsection{From \textit{Deduction modulo} to \lpcm}

Since the publication of \cite{zermodulo}, \lpcm~ has been developped as an evolution of \textit{Deduction modulo}.

More specifically, \lpcm~ allows to quantify on proposition.

In \dedukti, the symbol $mem$ and $rel$ are useless. Indeed, we can apply a node $x$ to class $P$ with $P~x$ and two nodes $x$ and $y$ to a relation $r$ with $r~x~y$.

Similarly, the symbols $g_{x,y_1,...,y_n,P}$ and $g'_{x,x',y_1,...,y_n,P}$ are not necessary in \dedukti. These symbols were specific constructors that allows to introduce in $mem$ a proposition $P$ by convert it into a class. \\

The rewriting rule $$y = z \ \lra \ \fa \ p \ (mem(y, p) \ \imp \ mem(z, p))$$ is not required as it is a $mem$ is useless in \lpcm.


\subsection{Rewriting rules}

All the other rewriting rules, except the ones involving $comp$, are easy to implement in \dedukti.

\begin{lstlisting}
rule eta (cr $a $z) $x $y ↪ eta $a $x $y;
rule root (cr $a $x) ↪ $x;
rule (cr (cr $a $x) $y) ↪ cr $a $y;

rule i' (i $x) ↪ $x;
rule j' (j $x) ↪ $x;
rule ρ^ (ρ $x) ↪ $x;
rule I (i $x) ↪ ⊤;
rule J (j $x) ↪ ⊤;
rule I (j $x) ↪ ⊥;
rule J (i $x) ↪ ⊥;
rule I (o) ↪ ⊥;
rule J (o) ↪ ⊥;

rule Pred (Succ $x) ↪ $x ;
rule Null O ↪ ⊤;
rule Nat O ↪ ⊤;
rule Null (Succ $x) ↪ ⊥;
rule Nat (Succ $x) ↪ Nat $x;

rule $x < O ↪ ⊥;
rule $x < (Succ $y) ↪ ($x < $y) ∨ ($x = $y);

rule $a simeq $b ↪ `∃ r : El (node arrow (node arrow prop)), 
    r (root $a) (root $b)
    ∧ (`∀ x, `∀ x', `∀ y, 
        eta $a x' x ∧ r x y
            ⇒ `∃ y', eta $b y' y ∧ r x' y')
    ∧ (`∀ y, `∀ y', `∀ x, 
        eta $b y' y ∧ r x y
            ⇒ `∃ x', eta $a x' x ∧ r x' y');

rule $a ∈ $b ↪ `∃ x, ((eta $b x (root $b)) ∧ ($a simeq cr $b x));

rule eta (join $a) $x $x' ↪ 
	(`∃ y, `∃ y', ($x = i y) ∧ ($x' = i y') ∧ eta $a y y')
    ∨ (`∃ y, `∃ z, ($x = i y) 
    	∧ ($x' = o) 
    	∧ eta $a y z 
    	∧ eta $a z (root $a));

rule eta (pair $a $b) $x $x' ↪ 
	(`∃ y, `∃ y', (($x = i y) ∧ ($x' = i y') ∧ eta $a y y'))
    ∨ (`∃ y, `∃ y', ($x = j y) ∧ ($x' = j y') ∧ eta $b y y')
    ∨ (($x = i (root $a)) ∧ ($x' = o))
    ∨ (($x = j (root $b)) ∧ ($x' = o));

rule eta (powerset $a) $x $x' ↪ 
	(`∃ y, `∃ y', ($x = i y) ∧ ($x' = i y') ∧ eta $a y y')
    ∨ (`∃ y, `∃ c, ($x = i y) 
    	∧ ($x' = j (ρ c)) 
    	∧ (eta $a y (root $a)) 
    	∧ ((cr $a y) ∈ c))
    ∨ (`∃ c, ($x = j (ρ c)) ∧ ($x' = o));

symbol omega : El graph;
rule eta omega $x $x' ↪ 
	(`∃ y, `∃ y', ($x = i y) ∧ ($x' = i y') ∧ (y < y'))
    ∨ (`∃ y, ($x = i y) ∧ ($x' = o) ∧ Nat y);

rule eta (Cl $a) $x $x' ↪ 
	(`∃ y, `∃ y', (($x = i y) ∧ ($x' = i y') ∧ eta $a y y'))
    ∨ (`∃ y, ($x = i y) 
        ∧ ($x' = o)
        ∧ (`∀ c : El (node arrow prop), 
                ((`∀ z, eta $a z (root $a) ⇒ c z)
                ∧ (`∀ z, `∀ z', (eta $a z z') ∧ (c z') ⇒ (c z)))
            	⇒ c y));
            
rule root (join $a) ↪ o;
rule root (pair $a $b) ↪ o;
rule root (powerset $a) ↪ o;
rule root omega ↪ o;
rule root (Cl $a) ↪ o;

\end{lstlisting}


\section{The language of formulas}

We may have notice that the lemmas in which the $comp$ symbol is used are only valid for a subset of formulas. The formulas need to have all of its quantifiers of sort $El~graph$ and can only use the language $\in$, $\simeq$ and the classic logical connectives.

Thus we need to introduce a set to caraterize the validity domain of such lemmas.

\subsection{Formulas}

In order to achieve this goal, we define the constant $formula$ of type $\Set$ and the logical connectives related to this constant.

\begin{lstlisting}
constant symbol formula : Set;
constant symbol eqF : El nat → El nat → El formula;
constant symbol inF : El nat → El nat → El formula;
constant symbol andF : El formula → El formula → El formula;
constant symbol orF : El formula → El formula → El formula;
constant symbol allF : El nat → El formula → El formula;
constant symbol exF : El nat → El formula → El formula;
constant symbol impF : El formula → El formula → El formula;
constant symbol fF : El formula;
constant symbol tF : El formula;
\end{lstlisting}

Then we are able to define an induction over formulas, using the language $\in$, $\simeq$ and the classic logical connectives.

\begin{lstlisting}
constant symbol recF : Π (P : El formula → Prop), 
π(`∀ x, `∀ y, P (eqF x y))
→ π(`∀ x, `∀  y, P (inF x y))
→ π(`∀ f, `∀ g, (P f ∧ P g) ⇒ (P (andF f g)))
→ π(`∀ f, `∀ g, (P f ∧ P g) ⇒ (P (orF f g)))
→ π(`∀ f, `∀ g, (P f ∧ P g) ⇒ (P (impF f g)))
→ π(`∀ f, (P f) ⇒ (`∀ x, P (allF x f)))
→ π(`∀ f, (P f) ⇒ (`∀ x, P (exF x f)))
→ π(P tF)
→ π(P fF)
→ π(`∀ f, P f);
\end{lstlisting}

\subsection{Interpretation}

The next step is to interpret an object of type $formula$ into $Prop$. We introduce the constant $interpretation$ which receives a valuation of type $\El \ nat \ \ra \ \El~graph$ and a formula of type $\El \ formula$ and return a $\El~prop$.

\begin{lstlisting}
symbol interpretation : (El nat → El graph) → El formula → El prop;
\end{lstlisting} 

We need to have a tool to update a valuation when we assign a variable. To do so, we introduce the constant $update$ of type $(\El \ nat \ra \El~graph) \ra \El \ nat \ra \El~graph \ra (\El \ nat \ra \El~graph)$ which takes as arguments a valuation $\sigma$, a natural number $x$ and a graph $a$ and returns a new valuation $(update \ \sigma \ x \ a)$ that substitues $x$ by $a$ and acts like $\sigma$ for the other natural numbers.

To write a rewriting rule upon $update$, we need to be able to check if we apply $(update \ \sigma \ x \ a)$ to $z = x$ or to $z \neq x$.

We define the symbol $update1$ of type $(\El \ nat \ \ra \ \El~graph) \ \ra \ \El \ nat \ \ra \ \El~graph \ \ra \ \El \ nat \ \ra \ (\El \ nat \ \ra \ \El~graph)$. The new argument $z$ is used to keep in memory the argument $y$:

$$update \ \sigma \ x \ a \ y \ \lra \ update1 \ \sigma \ x \ a \ y \ y$$

We have two natural numbers to compare: $x$, which is substitued by $a$, and $y$ that is the argument we apply to the valuation. The technique we use to compare $x$ and $y$ is the following: 

\begin{itemize}
\item We keep in memory $y$ in the variable $z$;
\item We decrement $x$ and $y$ until either one or both are equal to zero;
\item If both are equal to zero, then $x$ and $y$ are equal and we return $a$. If only one equals zero, then they are different and we return $\sigma \ z$.
\end{itemize}

$$update1 \ \sigma \ (s \ x) \ a \ (s \ y) \ z \ \lra \ update1 \ \sigma \ x \ a \ y \ z$$
$$ update1 \ \sigma \ zero \ a \ zero \ z \ \lra \ a$$
$$update1 \ \sigma \ zero \ a \ (s \ y) \ z \ \lra \ \sigma \ z$$
$$update1 \ \sigma \ (s \ x) \ a \ zero \ z \ \lra \ \sigma \ z$$


Now we have all the tools to define the rewiting rules of the interpreation of formulas:

$$interpretation \ \sigma \ (eqF \ x \ y) \lra (\sigma \ x) \ \simeq \ (\sigma \ y)$$
$$interpretation \ \sigma \ (inF \ x \ y) \lra (\sigma \ x) \ \in \ (\sigma \ y)$$
$$interpretation \ \sigma \ (andF \ f \ g) \lra (interpretation \ \sigma \ f) \conj (interpretation \ \sigma \ g)$$
$$interpretation \ \sigma \ (orF \ f \ g) \lra (interpretation \ \sigma \ f) \disj  (interpretation \sigma \ g)$$
$$interpretation \ \sigma \ (impF \ f \ g) \lra (interpretation \ \sigma \ f) \imp (interpretation \ \sigma \ g)$$
$$interpretation \ \sigma \ (allF \ x \ f) \ \lra \ \fa \ a, interpretation \ (update \ \sigma \ x \ a) \ f$$
$$interpretation \ \sigma \ (exF \ x \ f) \ \lra \ \ex \ a, interpretation \ (update \ \sigma \ x \ a) \ f$$
$$interpretation \ \sigma \ fF \lra \blbot$$
$$interpretation \ \sigma \ tF \lra \bltop$$

\subsection{Results concerning valuation}

Thanks to the introduction of $interpretation$, we can deduce five theorems. \\

The first theorem is used to simplify the terms when updating a valuation.

\begin{theorem}
$\fa \ \sigma, \fa \ x, y, z, \fa \ a, [(eqNP \ x \ y) \ \imp \ (((update1 \ \sigma \ x \ a) \ y \ z) \ \simeq \ a)] \ \conj \ [\blneg(eqNP \ x \ y) \ \imp \ (((update1 \ \sigma \ x \ a) \ y \ z) \ \simeq \ (\sigma \ z))]$
\end{theorem}

\begin{proof}
The first term of the conjonction is proved by simple recurrence over natural numbers. The second term of the conjonction is proved by double recurrence. $\square$
\end{proof}

The second theorem conveys the idea that if two graphs are bisimilar then it is identical to update a valuation by either of theses two graphs.

\begin{theorem}
$\fa \ \sigma, \fa \ x, \fa \ a, b, (a \ \simeq \ b) \ \imp \ [\fa y, (update \ \sigma \ x \ a \ y) \ \simeq \ (update \ \sigma \ x \ b \ y)]$
\end{theorem}

\begin{theorem}
$\fa \ \sigma, \fa \ x, y, \fa \ a, b, c, (a \ \simeq \ b) \ \imp \ (\fa z, (update \ (update \ \sigma \ x \ a) \ y \ c \ z) \ \simeq \ (update \  (update \ \sigma \ x \ b) \ y \ c \ z))$
\end{theorem}

The fourth theorem states that if two valuations are equal they keep being equal after an update.

\begin{theorem}
$\fa \ \sigma, \sigma', \fa \ x, \fa \ c, (\fa y, \sigma \ y \ \simeq \ \sigma' \ y) \ \imp \ (\fa z, (update \ \sigma \ x \ c \ z) \ \simeq \ (update \ \sigma' \ x \ c \ z))$
\end{theorem}

\begin{theorem}
$\fa \ f, \fa \ \sigma, \sigma', (interpretation \ \sigma \ f) \ \conj \ (\fa x, (\sigma \ x) \ \simeq \ (\sigma' \ x))) \ \imp \ (interpretation \ \sigma' \ f)$
\end{theorem}

\begin{proof}
The fifth theorem is proved by induction over formulas. $\square$
\end{proof}

\subsection{Comprehension and infinity}

Henceforth, we are able to define in \dedukti
$$comp : \El~graph \ra (\El \ nat \ \ra \ \El~graph) \  \ra \El \ formula \ra \ \El~graph$$

and its rewriting rules

\begin{lstlisting}
rule eta (comp $a $σ $f) $x $x' ↪ 
(`∃ y, `∃ y', (($x = i y) ∧ ($x' = i y') ∧ eta $a y y')) 
∨ (`∃ y, ($x = i y) ∧ ($x' = o) ∧ (eta $a y (root $a))
∧ (interpretation (update $σ zero (cr $a y)) $f));
rule root (comp $a $σ $f) ↪ o;
\end{lstlisting}

When it comes to symbol related to the Infinity section of \cite{zermodulo}, we implement $empty\_set$ of type $\El~graph$ and $Ind$ of type $\El~graph \ \ra \ \El~prop$.

To define the empty set, we use $comp$ with the formula $fF$:
\begin{lstlisting}
rule empty_set ↪ comp omega (λ _, empty_set) fF;
rule root empty_set ↪ o;
\end{lstlisting}

Then we implement

\begin{lstlisting}
rule Ind $c ↪ (empty_set ∈ $c) 
∧ (`∀ a, (a ∈ $c) ⇒ ((join (pair a (pair a a))) ∈ $c));
\end{lstlisting}


\section{Lemmas}

The first lemma $x=x$ does not need to be implemented since it is already part of the standard library of \dedukti \ under the name $refl$ (which is polymorphic).

The second lemma is already a consequence of the rewriting rule of the polymorphic $=$ implemented in the stardard library of \dedukti: 
\begin{lstlisting}
constant symbol = [s] : El s → El s → El prop;
notation = infix 4;
rule π (@= $s $x $y) ↪ Π (P : El $s → El prop), π(P $x) → π(P $y);
\end{lstlisting}

All the other lemmas of IZmod except the ones where $comp$ is involved are proved using the blueprint in \cite{zermodulo53}. The complete proofs can be found in \url{https://github.com/ttraversie/zf/tree/main/theoriezf}.

\subsection{An example of proof}

To show the way lemmas are proved in \dedukti ~we will take the example of lemma 30 and comment its proof. This lemma states that $$ a \in b \conj a \simeq c \imp c \in b $$

\begin{proof}
We first assume graphs $a$, $b$ and $c$ and $H$ the proof of $ a \in b \conj a \simeq c $. $a \in b$ rewrites to $\ex x~(x~\eta_b~root~b \conj a \simeq (b/x))$. 

We make appear $x$ and $Hx$ the proof $x~\eta_b~root~b \conj a \simeq (b/x)$. 

As the goal is to prove $c \in b$, that is to say $\ex y~(y~\eta_b~root~b \conj c \simeq (b/y))$, we need to find a suitable $y$. We take $x$ and now have two goals: $y~\eta_b~root~b$ and $c \simeq (b/y)$. 

The first one is proved by applying the left part of $Hx$. 

The second one is obtained by applying lemma 5 to $c$, $a$ and $b/x$. To apply lemma 5, we need to prove $c \simeq a \imp a \simeq b/x$. $c \simeq a$ is proved applying reflexivity to $a \simeq c$ (i.e. applying lemma 4 to $a$, $c$ and the right part of $H$). $a \simeq b/x$ derives from the right part of $Hx$. $\square$
\end{proof}

This proof is written in \dedukti thanks to the following code: 

\begin{lstlisting}
opaque symbol lemma30 : π(`∀ a, `∀ b, `∀ c, 
	((a ∈ b) ∧ (a simeq c)) ⇒ (c ∈ b))
≔ begin
assume a b c H;
refine ExElim node _ (and_eg _ _ H) _ _;
assume x Hx;
refine ExIntro node x _ _;
refine and_i _ _ _ _
{refine and_eg _ _ Hx}
{refine lemma5 c a (cr b x) 
	(and_i _ _ (lemma4 a c (and_ed _ _ H)) (and_ed _ _ Hx))}
end;
\end{lstlisting}

\subsection{Lemmas involving formulas}

Now that the language of formulas have been designed along with the implementation of the $comp$ symbol, lemma 32 can be implemented.

$$(P(z \leftarrow a) \conj a \simeq b) \imp P(z \leftarrow b)$$

We implement it thanks to the $interpretation$ symbol. The valuation $update~\sigma~z~a)$ represents the assignement of variable $z \leftarrow a$.

\begin{lstlisting}
opaque symbol lemma32 : Π (z : El nat), Π (f : El formula), 
π(`∀ a, `∀ b, (`∀ σ : (El nat → El graph),
((interpretation (update σ z a) f) ∧ (a simeq b)) 
⇒ (interpretation (update σ z b) f)))
\end{lstlisting}

The proof of this $opaque~symbol$ is done by induction over formulas: each case is proved easily, using the lemmas that have already been checked by \dedukti. \\

Lemma 41 is implemented similarly:

\begin{lstlisting}
opaque symbol lemma41 : Π (x y : El nat), Π (f : El formula), 
Π (c d : El graph), π(`∀ σ : (El nat → El graph), 
((interpretation (update (update σ x c) y d) f)
∧ (`∀ a, `∀ a', `∀ b, 
	((a' ∈ a) 
	∧ (interpretation (update (update σ x a) y b) f)) 
	⇒ (`∃ b', ((b' ∈ b) 
		∧ (interpretation (update (update σ x a') y b') f))))
∧ (`∀ b, `∀ b', `∀ a, 
	((b' ∈ b) 
	∧ (interpretation (update (update σ x a) y b) f)) 
	⇒ (`∃ a', ((a' ∈ a) 
		∧ (interpretation (update (update σ x a') y b') f))))) 
⇒ (c simeq d))
\end{lstlisting}

\subsection{Weak extensionnality}

\label{extensionality}

We notice in \cite{zermodulo53} the use of weak extensionality (or simply extensionality) to prove lemmas 44, 47 and 48. We want to deduce weak extensionality from strong extensionality (i.e. lemma 41). \\

\textbf{Weak extensionality.} $\fa~c,\fa~d, (\fa~z, (z \in c \Leftrightarrow z \in d) \imp c \simeq d)$ \\

We follow the blueprint given by G. Dowek and A. Miquel \cite{zermodulo} : we use the strong extensionality axiom where $R(x,y)$ is $(x \simeq c~\conj~y \simeq d)~\disj~x \simeq y$. \\

\begin{proof}
We want to prove that $\fa~c,\fa~d, (\fa~z, (z \in c \Leftrightarrow z \in d) \imp c \simeq d)$. We assume that $\fa~z, (z \in c \Leftrightarrow z \in d)$. We want to apply strong extensionality to deduce $c \simeq d$. To do so, we need to prove the three terms of the hypothesis of strong extensionality.

$(c \simeq c~\conj~d \simeq d)~\disj~c \simeq d$ is a tautology.

We want to prove that $\fa~a,\fa~a',\fa~b, (a' \in a~\conj~((a \simeq c~\conj~b \simeq d)~\disj~a \simeq b) \imp (\ex~b', (b' \in b~\conj~((a' \simeq c~\conj~b' \simeq d)~\disj~a' \simeq b'))$. We assume $(a' \in a~\conj~((a \simeq c~\conj~b \simeq d)~\disj~a \simeq b)$. If $(a \simeq c~\conj~b \simeq d)$, then we choose $b' \simeq a'$. We have $b' \in a$ because $a' \in a$. Yet, $a \simeq c$, $c \simeq d$ and $d \simeq b$. Then $b' \in b$. If $a \simeq b$, we choose $b' \simeq a'$. We have $b' \in a$ because $a' \in a$. Yet, $a \simeq b$. Thus $b' \in b$.

We procede similarly for the third term. $\square$
\end{proof}

We impelement this theorem in \dedukti:

\begin{lstlisting}
opaque symbol lemmaHypExt : Π (c d : Graph), 
π((`∀ z, (z ∈ c) ⇔ (z ∈ d)) ⇒ 
((((c simeq c) ∧ (d simeq d)) ∨ (c simeq d))
∧ (`∀ a, `∀ a', `∀ b, 
	((a' ∈ a) ∧ (((a simeq c) ∧ (b simeq d)) ∨ (a simeq b))) 
	⇒ (`∃ b', ((b' ∈ b) 
	∧ (((a' simeq c) ∧ (b' simeq d)) ∨ (a' simeq b')))))
∧ (`∀ b, `∀ b', `∀ a, 
	((b' ∈ b) ∧ (((a simeq c) ∧ (b simeq d)) ∨ (a simeq b)))
	 ⇒ (`∃ a', ((a' ∈ a) 
	 ∧ (((a' simeq c) ∧ (b' simeq d)) ∨ (a' simeq b')))))))
\end{lstlisting}

To prove $weak \ extensionality$, we assume graphs $c$ and $d$, and $H$ the hypothesis $\fa~z, (z \in c) \Leftrightarrow (z \in d)$. Then we apply lemma41 to:

\begin{itemize}
\item nats $zero$ and $one$
\item the formula $(orF~(andF~(eqF~zero~two)~(eqF~one~three))~(eqF~zero~one))$
\item graphs $c$ and $d$
\item the valuation $(update~(update~(\lambda \_, empty\_set)~two~c)~three~d)$ 
\item the proof of the left hand term $lemmaHypExt~c~d~H$.
\end{itemize}

Indeed, in the formula $$(orF~(andF~(eqF~zero~two)~(eqF~one~three))~(eqF~zero~one))$$ $zero$ and $one$ will be interpreted by $c$ and $d$ thanks to lemma41 and $two$ will be interpreted by $c$ and $three$ by $d$ thanks the valuation $$(update~(update~(\lambda \_, empty\_set)~two~c)~three~d)$$ The proposition obtained corresponds to the proposition in lemmaHypExt.


\begin{lstlisting}
opaque symbol lemmaExt : Π (c d : Graph), π((`∀ x, (x ∈ c) ⇔ (x ∈ d)) ⇒ (c simeq d))
≔ begin
assume c d H;
refine lemma41 zero one 
		(orF (andF (eqF zero two) (eqF one three)) (eqF zero one)) 
		c d 
		(update (update (λ _, empty_set) two c) three d) 
		(lemmaHypExt c d H);
end;
\end{lstlisting}

\section{Conclusion}

We have implemented in \dedukti ~a version of set theory -- IZst -- that respects normalization properties. IZst set theory correponds to Zermelo set theory, with Strong Extensionality axiom and Transitive Closure axiom. To do so, we have adapted the work by G. Dowek and A. Miquel \cite{zermodulo} from \textit{Deduction modulo} to \lpcm. We have \textit{formally} written all the proofs of the lemmas allowing us to implement set theory in \dedukti.


To define and prove the lemmas corresponding to Comprehension axiom, we have developped a language of formulas, along with operators \textit{interpretation} and \textit{update}. In particular, the language of formulas allows us to prove that Weak Extensionality axiom derives from Strong Extensionality axiom.

\begin{center}
\begin{tabular}{|c|c||c|c|}
\hline Lemma & Number of lines in the proof & Lemma & Number of lines in the proof \\
\hline 3 & ? & 29 & ? \\
\hline 4 & ? & 30 & ? \\
\hline 5 & ? & 31 & ? \\
\hline 6 & ? & 32 & ? \\
\hline 7 & ? & 33 & ? \\
\hline 8 & ? & 34 & ? \\
\hline 9 & ? & 35 & ? \\
\hline 10 & ? & 36 & ? \\
\hline 11 & ? & 37 & ? \\
\hline 12 & ? & 38 & ? \\
\hline 13 & ? & 39 & ? \\
\hline 14 & ? & 40 & ? \\
\hline 15 & ? & 41 & ? \\
\hline 16 & ? & 42 & ? \\
\hline 17 & ? & 43 & ? \\
\hline 18 & ? & Weak extensionality & ? \\
\hline 19 & ? & 44 & ? \\
\hline 20 & ? & 45 & ? \\
\hline 21 & ? & 46 & ? \\
\hline 22 & ? & 47 & ? \\
\hline 23 & ? & 48 & ? \\
\hline 24 & ? & 49 & ? \\
\hline 25 & ? & 50 & ? \\
\hline 26 & ? & 51 & ? \\
\hline 27 & ? & 52 & ? \\
\hline 28 & ? & 53 & ? \\
\hline
\end{tabular}
\end{center}

\printbibliography

\end{document}